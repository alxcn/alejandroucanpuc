<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Gram-Schmidt Process</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alejandro Ucan" />
    <meta name="date" content="2025-08-06" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <script type="application/json" id="xaringanExtra-editable-docid">{"id":"c0edafbaceb04274902f8c2b1ea1a172","expires":1}</script>
    <script src="index_files/himalaya/himalaya.js"></script>
    <script src="index_files/js-cookie/js.cookie.js"></script>
    <link href="index_files/editable/editable.css" rel="stylesheet" />
    <script src="index_files/editable/editable.js"></script>
    <script src="index_files/fabric/fabric.min.js"></script>
    <link href="index_files/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="index_files/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Gram-Schmidt Process
]
.subtitle[
## Session 08
]
.author[
### Alejandro Ucan
]
.date[
### 2025-08-06
]

---








# Goals of the Session

* Construct orthonormal bases. &lt;br/&gt;&lt;br/&gt;

---
# Motivation

An assembly line has three workstations `\((A, B, C)\)` whose output metrics show correlations. The initial measurement vectors are: `\(v_1 = (2, 1, 1), v_2 = (1, 3, 1), v_3 = (0, 1, 2).\)` The quality control team wants to ensure that the production process is efficient and balanced across these dimensions, meaning that this proposal is an orthonormal basis. The team wants to construct an orthonormal basis from these vectors. How correlation can be measured between these vectors? &lt;br/&gt;&lt;br/&gt; How can we construct an orthonormal basis from these vectors?


---
## Orthogonal and Orthonormal Bases


&gt; **Definition:** Let `\(V\)` be a vector space with an inner product. A set of vectors `\(S = \{v_1, v_2, \ldots, v_n\}\)` is called orthogonal if for all `\(u, v \in S\)` with `\(u \neq v\)`, we have `\(\langle u, v \rangle = 0.\)` &lt;br/&gt;&lt;br/&gt; We say that `\(S\)` is orthonormal if it is orthogonal and `\(\langle u, u \rangle = 1\)` for all `\(u \in S.\)`

--
##### Example

The set `\(S=\left\{\left(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}},0\right),\left(-\frac{\sqrt{2}}{6},\frac{\sqrt{2}}{6},\frac{2\sqrt{2}}{3}\right),\left(\frac{2}{3},-\frac{2}{3},\frac{1}{3}\right)\right\}\)` is orthonormal.

---
## Orthogonal and Orthonormal Bases

&gt; **Theorem:** Let `\(V\)` be a vector space with an inner product, and let `\(S=\{v_1,v_2,\ldots,v_n\}\)` be a set of non-zero orthogonal vectors. Then `\(S\)` is linearly independent.

--
&lt;br/&gt;&lt;br/&gt;
&gt; **Corollary:** If `\(V\)` has dimension `\(n\)`, then any orthogonal set of `\(n\)` vectors is a basis.

---
# Gram-Schmidt Process

1. Let `\(S=\{v_1,v_2,\ldots,v_n\}\)` be a set of linearly independent vectors in `\(V.\)` &lt;br/&gt;&lt;br/&gt;
2. Define `\(u_1=v_1.\)` &lt;br/&gt;&lt;br/&gt;
3. For `\(k=2,3,\ldots,n,\)` define `\(u_k=v_k-\sum_{j=1}^{k-1}\frac{\langle v_k,u_j\rangle}{\langle u_j,u_j\rangle}u_j.\)` &lt;br/&gt;&lt;br/&gt;
4. Define `\(w_1=\frac{u_1}{\sqrt{\langle u_1,u_1\rangle}},\)` and for `\(k=2,3,\ldots,n,\)` define `\(w_k=\frac{u_k}{\sqrt{\langle u_k,u_k\rangle}}.\)` &lt;br/&gt;&lt;br/&gt;

---
##### Example:

Let `\(S=\{(1,1),(0,1)\}.\)` Construct an orthonormal basis from `\(S.\)` &lt;br/&gt;&lt;br/&gt;

--
##### Solution:
`\(v_1=(1,1)\)` and `\(v_2=(0,1).\)` Following the Gram-Schmidt process, we have `\(u_1=v_1\)` and `$$u_2=v_2-\frac{\langle v_2,u_1\rangle}{\langle u_1,u_1\rangle}u_1=v_2-\frac{1}{2}v_1=(-\frac{1}{2},\frac{1}{2}).$$` &lt;br/&gt;&lt;br/&gt; Therefore, `\(w_1=\frac{u_1}{\sqrt{\langle u_1,u_1\rangle}}=\frac{1}{\sqrt{2}}(1,1)\)` and `\(w_2=\frac{u_2}{\sqrt{\langle u_2,u_2\rangle}}=\left(-\frac{\sqrt{2}}{2},\frac{\sqrt{2}}{2}\right).\)` &lt;br/&gt;&lt;br/&gt;

---
##### Example:

Let `\(S=\{(1,1,1),(1,0,1),(1,1,0)\}.\)` Construct an orthonormal basis from `\(S.\)` &lt;br/&gt;&lt;br/&gt;

---
##### Example:

Let `\(S=\{(1,1,0),(1,2,0),(0,1,2)\}.\)` Construct an orthonormal basis from `\(S.\)`

---

## Applied Gram-Schmidt Process

An assembly line has three workstations `\((A, B, C)\)` whose output metrics show correlations. The initial measurement vectors are: `\(v_1 = (2, 1, 1), v_2 = (1, 3, 1), v_3 = (0, 1, 2).\)` The quality control team wants to ensure that the production process is efficient and balanced across these dimensions, meaning that this proposal is an orthonormal basis. The team wants to construct an orthonormal basis from these vectors. How correlation can be measured between these vectors? &lt;br/&gt;&lt;br/&gt; How can we construct an orthonormal basis from these vectors?

---

## Applied Gram-Schmidt Process

A robotic arm has three inertial measurement units (IMUs) producing correlated sensor data vectors given by `\(v_1 = (1,1,0), v_2 = (2,0,1), v_3 = (1,2,1),\)` that can be interpreted as IMU-XY, IMU-XZ, and IMU-XYZ couplings, respectively. The robotics team wants to ensure that the IMU data is processed efficiently and balanced across these dimensions, meaning that this proposal is an orthonormal basis. The team wants to construct an orthonormal basis from these vectors. Why does the initial proposal is not efficient? &lt;br/&gt;&lt;br/&gt; How can we construct an orthonormal basis from these vectors?

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "slideNumberFormat": "%current%",
  "highlightStyle": "github",
  "highlightLines": true,
  "ratio": "16:9",
  "countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
